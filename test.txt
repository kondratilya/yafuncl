0={};                               # нет литералов. {} неявно возвращает 0
1={++0;};                           # ++ неявно содержит 1. ++ не меняет значения переменной
2={++1;};                           # переменные содержат адреса функций, но не значения.
3={++2;};
4={++3;};
5={++4;};
6={++5;};
7={++6;};
8={++7;};
9={++8;};
10=+{++9;};

HelloWorld = ({7*10+2;}, 10*10+1, 10*10+8, 10*10+8, 10*10+10+1, 3*10+2, 10*10+10+9, 10*10+10+1, 10*10+10+4, 10*10+8, 10*10, 10+3, 10);
@@@ HelloWorld;

                                    #  @ - вывод в консоль. Не преобразует тип
                                    #  @@ - вывод в консоль с переносом строки
@2;                                 # 2 - функция, не числовое  значение, поэтому выводится адрес в "<>"
@@+2;                               # Арифметические операции вызывают функции-операнды. Поэтому "+" преобразует адрес функии "2={++1;}" в значение ("2")

@(1 == 1);                          # Арифметические операции
@(1 != 1);                          # +, -, *, /, %, унарные + и -
@(1 == {++0;});                     # ||, &&, ==, !=, >, <, >=, <=
@(1 != {});
@@(0 && 1 || 2);

a={@+arguments;};                   # функция выводящая и возвращающая значение приведенное к числу 
@@(0=>a || -3=>a || 10=>a);         # || возвращает первое ненулевое значение, но все побочные эффекты будут выполнены.
                                    # вывод "0" "3" "10" (побочные эффекты) "-3" (результат)

@@(1 - - ++ 2);
4=2+2;                              # При выполнении арифметических операций, если операнд является функцией, она вызывается (без аргументов) и используется ее значение.
                                    # 2 - функция (т.к =={++1}), но 4 - числовое значение, т.к "+" вызвал функции "2" 
5_3 = 2+3+3/10;         
@5_3;                   
@@(5_3 % 2);                        # остаток от деления

@+x = if 1!=1: 1 else: 3;           # if - else 
@x = if 0: 1;                       # перед else не стоит ;
@+x= if 1: {@+2;1+1;} else: {@1;3+4;}; # if или if-else возвращают значение. Если нет else и условие==false вернется "Undefined"
@@x = if 1==1: 1;
a=+0;
while a<10 : =>{ @a;a=++a; };       # цикл "while". Вызов без => возможен, но не имеет смысла.
@@a;

@ x={2+2+1;};                       #  x - Функция. Результат функции по умолчанию равняется результату последнего выражения.
@@ y={2+2+arguments;};              #  y - Функция. Параметры передаются через переменную arguments в контексте этой функции.

ret1 = {                            # Возврат из функции: return ; В данном случае вернет "0" т.к пустая функция 
   return ; @1; @2; return 10; @3;  # возвращает "0". Иначе вернется результат последнего выражения.
};
ret2 = {                            # Возврат из функции: return E;  В данном случае вернет указатель на функцию "10". 
   @1; @@2; return 10; @3;          # То же самое что и " 10; return; "
};

=>x;                                # Вызов функции
@(-2=>y);                           # Вызов функции с параметрами. Приоритет => выше чем у "-", поэтому передается значение "2" - результат "6"
@(-2)=>y;                           # Вызов функции с параметрами. Приоритет => выше чем у "-". результат 2 - аргумент в скобках
@@( (1,2)=>{@arguments;} );         # предача параметров через кортеж

plus= {                        # Замыкания
    b=arguments;
    {
        arguments+b;
    };
};
@plus2 = 2=>plus;                   # 2 остаются в контексте plus2
@plus3 = 3=>plus;                   # 3 остаются в контексте plus3
@10=>plus2;                         # 12
@@10=>plus3;                        # 13

@@a=(                               # Кортежи
    1,
    (-2-3, ),
    (),
    (3, 3+1, (1,()))
); 
@();                                # Пустой кортеж
@@(1,);                             # Кортеж с 1 элементом. (только в случае 1 элемента может быть ',' в конце)

c=+10;
(a, b) = (+1, +2);                  # Распаковка кортежа
@a;@b;@c;
(a, b) = (+1, +2, +3);              # Распаковка кортежа - пропуск лишних инициализаторов
@(a,b,c);
(a, b, c) = (+1, +2);               # Распаковка кортежа - установка в "Undefined" если не хватает инициализаторов
@(a,b,c);
(a, b, c) = +1;                     # Распаковка кортежа - праввое значение преобразуется в кортеж
@@(a,b,c);

                                    # Пока в конце файла должен быть пробельный символ 

