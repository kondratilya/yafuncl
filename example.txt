0={};                               # нет литералов. По задумке). {} неявно возвращает 0
1={++0;};                           # "++" неявно содержит 1. "++" не меняет значения переменной
2={++1;};                           # переменные содержат адреса функций, но не значения.
3={++2;};
4={++3;};                           # гораздо эффективнее 4=+{++3;}, но менее "функционально" ;)
5={++4;};
6={++5;};
7={++6;};
8={++7;};
9={++8;};
10={++9;};

HelloWorld = ({7*10+2;}, 10*10+1, 10*10+8, 10*10+8, 10*10+10+1, 3*10+2, 10*10+10+9, 10*10+10+1, 10*10+10+4, 10*10+8, 10*10, 10+3, 10);
@@@ HelloWorld;
                                
                                    #  @ - вывод в консоль. Не преобразует тип
                                    #  @@ - вывод в консоль с переносом строки;
                                    #  @@@ - вывод в консоль в виде chr'ов
@2; ;                               # 2 - функция, не числовое  значение, поэтому выводится адрес в "<>"
@@+2;                               # Арифметические операции вызывают функции-операнды. Поэтому "+" преобразует адрес функии "2={++1;}" в значение ("2")

immutable Y=10*8+9;                 # по умолчанию переменные immutable. Но можно задать явно
immutable N=10*7+8;

@(1 == 1);                          # Арифметические операции
@(1 != 1);                          # +, -, *, /, %, унарные + и -
@(1 == {++0;});                     # ||, &&, !, ==, !=, >, <, >=, <=
@(1 != {});
@@(0 && 1 || 2);
@@(0 || {} || +0);                  # результат - значение "0". Возвращается последний аргумент, если оба приводятся к 0
r={+@arguments;};                   # функция выводящая и возвращающая значение приведенное к числу 
@@(0=>r || (-3)=>r || 10=>r);       # || возвращает первое ненулевое значение, но все побочные эффекты будут выполнены.
                                    # вывод "0" "3" "10" (побочные эффекты) "-3" (результат)

@@(1 - - ++ 2);                     # Некоторые унарные операции
#4=2+2;                              # При выполнении арифметических операций, если операнд является функцией, она вызывается (без аргументов) и используется ее значение.
                                    # 2 - функция (т.к =={++1}), но 4 - числовое значение, т.к "+" вызвал функции "2" 
5_3 = 2+3+3/10;         
@5_3;                   
@@(5_3 % 2);                        # остаток от деления

@ x={2+2+1;};                       #  x - Функция. Результат функции по умолчанию равняется результату последнего выражения.
@@ y={2+2+arguments;};              #  y - Функция. Параметры передаются через переменную arguments в контексте этой функции.

ret1 = {                            # Возврат из функции: return ; В данном случае вернет "0" т.к пустая функция 
   return ; @1; @2; return 10; @3;  # возвращает "0". Иначе вернется результат последнего выражения.
};
ret2 = {                            # Возврат из функции: return E;  В данном случае вернет указатель на функцию "10". 
   @1; @@2; return 10; @3;          # То же самое что и " 10; return; "
};

=>x;                                # Вызов функции
@(- 2=>y);                          # Вызов функции с параметрами. Приоритет => выше чем у "-", поэтому передается значение "2" - результат "6"
@(-2)=>y;                           # Вызов функции с параметрами. Приоритет => выше чем у "-". результат "2" - аргумент в скобках
@@( (1,2)=>{@arguments;} );         # предача параметров через кортеж

                                    # модификаторы
@mutable a=+1;                      # по умолчанию переменные неизменяемые. mutable делает переменную изменяемой. Можно указвывать immutable. Менять тип после присвоения нельзя
immutable smth; smth = 66; 
                                    # области видимости 
@mutable b=+2;                      # по умолчанию просматривается свой контекст, затем всех родителей по очереди. 
                                    # используется первая нашедшаяся переменная. Если не найдена, она создается в своем контексте.
=> mutable {                        # модификатор mutable для всего блока. По умолчанию все переменные будут изменяемыми
    @inner a=+3;                    # внутренняя a - создается в своем контексте
    @outer a;                       # внешняя a - просматриваются родители, пока не найдена. 
    @outer b=+4;
    @a=+5;
    @a;                             # a внутренняя - т.к было создана inner.
    @b;                             # внешняя b
};
@a;@@b;                             # а не изменилась, b изменилась

=> inner {                          # модификатор inner для всего блока. По умолчанию все переменные будут такой области видимости (возможно только inner). 
    @inner mutable a= +outer 7;     # переменная "0" отсутствует в контексте, можно взять из внешнего
    @outer a;                       
    @outer b;
    @@a= ++ ++ ++++a;
};
@a;@@b;

plus = inner {                      # Замыкания
    b=arguments;                    # inner чтобы использовать локальную b
    {
        arguments+b;
    };
};
@plus2 = 2=>plus;                   # 2 остаются в контексте plus2
@plus3 = 3=>plus;                   # 3 остаются в контексте plus3
@10=>plus2;                         # 12
@@10=>plus3;                        # 13

recursion = {                       # Рекурсии
    (a, ) = arguments;
    @a;
    if a < 10: 
        (a+1)=>recursion 
    else: 
        @@@(10, 10+3);              # "\r\n"
};
1=>recursion;

i1 = {                              # Вложенные вызовы (и доступ по индексу)
    (
        2,3,4,
        { 
            @?WeAreHere; 
            @arguments;(arguments+0, arguments+1, arguments+2);
        }
    );
};
@(8=>((=>i1)[3]))[2];


@@a=(                               # Кортежи
    1,
    (-2-3, ),
    (),
    (3, 3+1, (1,()))
); 
@a=>length;                         # длинна кортежа
@1=>length;                         # операции с кортежами преобразуют в кортеж
@a[1];                              # Доступ по индексу 
@a[3][2];                           # Доступ по индексу 
@@a[3][-2] = 3+3;                   # Доступ по индексу с конца, приравнисание по индексу
@@a;
@@...10;                            # Преобразование в кортеж
@();                                # Пустой кортеж
@@(1,);                             # Кортеж с 1 элементом. Только в случае 1 элемента может быть ',' перед ")". (1,) то же что и ...1, но может быть слева
# immutable imm = (1, 2, 3);        
# imm[1]=6;                         # ! не выполнится, т.к "imm" - неизменяемая

mutable c=+10;                      # Распаковка кортежа. mutable-immutable работает при распаковаке
(a, b) = (+1, +2);                  
@a;@b;@@c;
(a, b) = (b, a);                    # Перестановка значений через распаковку кортежа
@a;@@b;
(a, b) = (+1, +2, +3);              # Распаковка кортежа - пропуск лишних инициализаторов
@(a,b,c);
(a, b, c) = (+1, +2);               # Распаковка кортежа - установка в "Undefined" если не хватает инициализаторов
@(a,b,c);
(a, b, c) = +1;                     # Распаковка кортежа - праввое значение преобразуется в кортеж
@@(a,b,c);

                                    # Условия:
if 1!=1: @1 else: @3;               # "if" - "else" . Перед "else" не стоит ;
@ mutable z = if 0: 1;              # 
z= if 1:                            # "if" или "if-else" возвращают значение. Если нет else и условие==false вернется "Undefined"
    { @+2; 1+1; } 
else: 
    { @1; 3+4; }; 
@z;
@@(z = (if 1==1: 1)+2)+2;           # "if" - опретор, может участвовать в выражениях

{ return if a; };                   # "return" - "if": Управление потоком. "return - if" - выражение, не может быть частью выражения
{ return 1 if a; };                 # можно возвращать значение, или будет возвращен результат последнего выражения
{ return ; return 1; };             # безусловный return. 

mutable i=0;                        # Циклы
while {                             # "while" выполняется, пока результат функции не равен 0;
    i=++i;
    if i%2 : @i;
    return 0 if i > 5;              # "return true" == "continue", "return false" == "break"
    i<10;
};
@@i;

a=+0;
while a<10 : =>{ @a;a=++a; };       # "while" с вынесенным условием. Вызов без => возможен, но не имеет смысла. Неканонично ;). Нет аналога continue и break;
@@a;                                

while { @a;a>0; } : =>{ a=--a; };   # можно инкреимент указывать после ":".
@@a;                                


@@@ (if (a,2) : Y else: N) + 0 ; 
@@@ (if () : Y else: N) + 0 ; 
a=(1,);
@@@ (if a : Y else: N) + 0 ; 
a=();
@@@ (if a : Y else: N) + 0 ; 
@@@ (if cffctf : Y else: N) + 0 ; 
@@(a=(1,2,3)+(4,5,6));

baseFactory = inner {               # Фабрика, Возвращает функцию для перевода числа из системы счисления в параметре
    (base, ) = arguments;
    0 = outer 0;
    {
        (digits = arguments);
        mutable i = digits=>length;
        mutable sum = 0;
        mutable multiplyer = ++0;
        while {
            i = --i;
            return 0 if i<0;
            sum = sum + digits[i] * multiplyer;
            multiplyer = multiplyer * base;                 # multiplyer никогда не равен "0"; Но правильнее явно поставить в конце "true;"
        };
        sum;
    };
};
base2  = (++1)=>baseFactory;        # перевод из 2-чной системы. 
base10 = ((1,0,1,0)=>base2)=>baseFactory;  # перевод из 10-чной системы.  (параметр: 1010 base2 = 10 base10). 

@(1,0,1,1)=>base2;
@@(1,1,9)=>base10;

empty = {                           # возвращает пустое ли значение в параметре
    (...arguments)=>length == 0;
};
@xxx=>empty;
a=1;@a=>empty;
a=0;@@a=>empty;

@?Have; @?a; @?nice; @?day; @@@((3,3)=>base10, 10+3, 10); 


abs = inner {
    (a, ) = arguments;
    if a < {}: -a else: a;
};

range = inner {
    (mutable from, mutable to, mutable step) = ...arguments;
    outer abs;
    step = (step)=>outer abs;
    mutable result = ();
    f = if from < to : {
        while {
            result = result + from;
            from = from + step;
            from < to;
        };
    } else: {
        while {
            result = result + from;
            from = from - step;
            from > to;
        };
    };
    =>f;
    result;
};

@@tuple1 = ((+2,+10,+1)=>range);
@@tuple2 = ((+2*10+5,+10+1,1)=>range);
@@tuple3 = ((+3*10+6,+5*10+8,3)=>range);

iterator = inner {
    (list, ) = ...arguments;
    mutable index;
    first = { @?first; @@index = {}; };
    next = { @?next; @@index = ++ index; @list[index]; };
    condition = { @?condition; @@(index < list=>length); };
    (first, next, condition);
};


@@it1 = tuple1=>iterator;
