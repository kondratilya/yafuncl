0={};                               # нет литералов. По задумке). {} неявно возвращает 0
1={++0;};                           # ++ неявно содержит 1. ++ не меняет значения переменной
2={++1;};                           # переменные содержат адреса функций, но не значения.
3={++2;};
4={++3;};                           # гораздо эффективнее 4=+{++3;}, но менее "функционально" ;)
5={++4;};
6={++5;};
7={++6;};
8={++7;};
9={++8;};
10={++9;};

HelloWorld = ({7*10+2;}, 10*10+1, 10*10+8, 10*10+8, 10*10+10+1, 3*10+2, 10*10+10+9, 10*10+10+1, 10*10+10+4, 10*10+8, 10*10, 10+3, 10);
@@@ HelloWorld;

                                
                                    #  @ - вывод в консоль. Не преобразует тип
                                    #  @@ - вывод в консоль с переносом строки
                                    #  @@@ - вывод в консоль в виде chr'ов
@2;                                 # 2 - функция, не числовое  значение, поэтому выводится адрес в "<>"
@@+2;                               # Арифметические операции вызывают функции-операнды. Поэтому "+" преобразует адрес функии "2={++1;}" в значение ("2")

@(1 == 1);                          # Арифметические операции
@(1 != 1);                          # +, -, *, /, %, унарные + и -
@(1 == {++0;});                     # ||, &&, ==, !=, >, <, >=, <=
@(1 != {});
@@(0 && 1 || 2);

a={@+arguments;};                   # функция выводящая и возвращающая значение приведенное к числу 
@@(0=>a || -3=>a || 10=>a);         # || возвращает первое ненулевое значение, но все побочные эффекты будут выполнены.
                                    # вывод "0" "3" "10" (побочные эффекты) "-3" (результат)

@@(1 - - ++ 2);                     # Некоторые унарные операции
4=2+2;                              # При выполнении арифметических операций, если операнд является функцией, она вызывается (без аргументов) и используется ее значение.
                                    # 2 - функция (т.к =={++1}), но 4 - числовое значение, т.к "+" вызвал функции "2" 
5_3 = 2+3+3/10;         
@5_3;                   
@@(5_3 % 2);                        # остаток от деления

@ x={2+2+1;};                       #  x - Функция. Результат функции по умолчанию равняется результату последнего выражения.
@@ y={2+2+arguments;};              #  y - Функция. Параметры передаются через переменную arguments в контексте этой функции.

ret1 = {                            # Возврат из функции: return ; В данном случае вернет "0" т.к пустая функция 
   return ; @1; @2; return 10; @3;  # возвращает "0". Иначе вернется результат последнего выражения.
};
ret2 = {                            # Возврат из функции: return E;  В данном случае вернет указатель на функцию "10". 
   @1; @@2; return 10; @3;          # То же самое что и " 10; return; "
};

=>x;                                # Вызов функции
@(- 2=>y);                          # Вызов функции с параметрами. Приоритет => выше чем у "-", поэтому передается значение "2" - результат "6"
@(-2)=>y;                           # Вызов функции с параметрами. Приоритет => выше чем у "-". результат 2 - аргумент в скобках
@@( (1,2)=>{@arguments;} );         # предача параметров через кортеж

plus= {                             # Замыкания
    b=arguments;
    {
        arguments+b;
    };
};
@plus2 = 2=>plus;                   # 2 остаются в контексте plus2
@plus3 = 3=>plus;                   # 3 остаются в контексте plus3
@10=>plus2;                         # 12
@@10=>plus3;                        # 13

@@a=(                               # Кортежи
    1,
    (-2-3, ),
    (),
    (3, 3+1, (1,()))
); 
@();                                # Пустой кортеж
@@(1,);                             # Кортеж с 1 элементом. Только в случае 1 элемента может быть ',' перед ")" 

c=+10;
(a, b) = (+1, +2);                  # Распаковка кортежа
@a;@b;@@c;
(a, b) = (b, a);                    # Перестановка значений через распаковку кортежа
@a;@@b;
(a, b) = (+1, +2, +3);              # Распаковка кортежа - пропуск лишних инициализаторов
@(a,b,c);
(a, b, c) = (+1, +2);               # Распаковка кортежа - установка в "Undefined" если не хватает инициализаторов
@(a,b,c);
(a, b, c) = +1;                     # Распаковка кортежа - праввое значение преобразуется в кортеж
@@(a,b,c);

                                    # Условия:
if 1!=1: @1 else: @3;               # "if" - "else" . Перед "else" не стоит ;
@x = if 0: 1;                       # 
x= if 1:                            # "if" или "if-else" возвращают значение. Если нет else и условие==false вернется "Undefined"
    { @+2; 1+1; } 
else: 
    { @1; 3+4; }; 
@x;
@@(x = (if 1==1: 1)+2)+2;           # "if" - опретор, может участвовать в выражениях

# return if a;                      # "return" - "if": Управление потоком. "return - if" - выражение, не может быть частью выражения
# return 1 if a;                    # можно возвращать значение, или будет возвращен результат последнего выражения
# return ; return 1;                # безусловный return

i=0;                                # Циклы
while {                             # "while" выполняется, пока результат функции не равен 0;
    i=++i;
    if i%2 : @i;
    return 0 if i==5;
    i<10;
};
@@i;

a=+0;
while a<10 : =>{ @a;a=++a; };       # "while" с вынесенным условием. Вызов без => возможен, но не имеет смысла. Неканонично ;)
@@a;

# Пока в конце файла должен быть незначащий символ (пробельный либо комментарий)
